<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 4 Notes and Code Examples</title>
    <link rel="stylesheet" href="main.css">
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&display=swap" rel="stylesheet">
</head>

<body>
    <nav>
        <ul id="navigation">
            <li><a href="#" id="menu">&equiv; Menu</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/index.html">Home</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week1/">Week 1</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week2/">Week 2</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week3/">Week 3</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week4/">Week 4</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week5/">Week 5</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week6/">Week 6</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week7/">Week 7</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week8/">Week 8</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week9/">Week 9</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week10/">Week 10</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week11/">Week 11</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week12/">Week 12</a></li>
            <li><a href="https://spencerasj.github.io/wdd330/week13/">Week 13</a></li>
        </ul>
    </nav>
    <h1>Chapter 8: Forms</h1>
    <div>
        <ul>
            <li>If you'd like to learn more about how to design forms that are accessible and enhance the user experience then Designing UX: Formsby Jessica Enders is well worth a read</li>
            <li>The <span class="word">action</span> attribute is the URL that the form will be submitted to so it can be processed on the server side. </li>
            <li>We can also access the form controls using their 'name' attributes as if it was a property of the form object.<br><span class="examples">const input = form.searchInput</span></li>
            <li>The <span class="word">form.submit()</span> method will submit the form automatically. Note that submitting a form using this method won’t trigger the form <span class="word">submit event</span></li>
            <li><span class="examples">button type='submit'>Submit/button<br>
                input type='submit' value='Submit'<br>
                input type='image' src='button.png'</span></li>
            <li><span class="examples">button type='reset'>Reset button</span></li>
            <li>Reset buttons are generally considered poor for usability, as they are too easy to click and then wipe out all the data that’s been entered. So think very carefully before using one in a form.</li>
            <li><span class="research">Learn More about: Form Events such as blur, focus, change.  The placeholder attribute, hidden input fields, input types <span class="examples">number, tel and color.</span> </span></li>
            <li>Text input element objects have a value property that can be used to retrieve the text inside the field.<br><span class="examples"><span class="word">input fields</span> , including text, passwords, check boxes, radio buttons, and file uploads<br>
                <span class="word">select menus</span> for drop-down lists of options<br>
                <span class="word">textarea</span> elements for longer text entry<br>
                <span class="word">button</span> elements for submitting and resetting forms</span></li>
            <li>A <span class="word">file input field</span> can be created using input fields with type='file' . These are used to upload files, and most browsers will provide a browse button or similar that lets users select a file from their file system.</li>
            <li>Form validation is the process of checking whether a user has entered the information into a form correctly.<br> <span class="examples">Examples:<br>A required field is completed
            An email address is valid<br>
            A number is entered when numerical data is required<br>
            A password is at least a minimum number of characters</li>
            <li>We can improve the usability of the form further by giving instant feedback, instead of waiting for the form to be submitted.This can be achieved by adding the event listener directly to the input field that will fire when the user presses a key</li>
            <li>A submit button can be disable by added the <span class="word">disabled attribute </span>to the <span class="word">input</span> element:<br><span class="examples">button type='submit' id='submit' disabled Submit button</span> </li>
        </ul>
    <h1>Chapter 12 Notes: Object Oriented Programming</h1>  
    <div>
        <ul>
            <li>There are three main concepts in OOP: <span class="word">encapsulation, polymorphism and inheritance.</span></li>
            <li><span class="word">Encapsulation:</span> In OOP, this involves keeping all the programming logic inside an object and making methods available to implement the functionality, without the outside world needing to knowhowit’s done</li>
            <li><span class="word">Polymorphism:</span> In OOP, this means various objects can share the same method, but also have the ability to override shared methods with a more specific implementation.</li>
            <li><span class="word">Inheritance:</span> In OOP, this means we can take an object that already exists and inherit all its properties and methods. We can then improve on its functionality by adding new properties and methods.</li>
            <li>Many object-oriented languages, such as Java and Ruby, are known as <span class="word">class-based</span> languages. </li>
            <li>We can now create an <span class="word">instance</span> of the dice constructor function using the <span class="word">new</span> operator.<br><span class="examples">Examples:<br>const redDice = new Dice;</span></li>
            <li>The parentheses are required, however, if any default arguments need to be provided.</li>
            <li>JavaScript contains a number of built-in constructor functions such as <span class="word">Object , Array , and Function</span> that can be used to create objects, arrays and functions instead of literals.</li>
            <li>Array constructor functions exhibit some strange behavior regarding the arguments supplied, however. If only one argument is given, it doesn’t create an array with that argument as the first element, as you might expect. It sets the array’s length property instead, and returns an array full of undefined</li>
            <li><span class="word">the newclass declaration syntax</span><br> <span class="examples">class Dice {<br>
                constructor(sides=6) {<br>
                    this.sides = sides;<br>
                }<br>
                roll() {<br>
                    return Math.floor(this.sides * Math.random() + 1)<br>
                }<br>
            }</span></li>
            <li>Static methods are not available to instances of the class</li>
            <li>JavaScript uses a prototypal inheritance model. This means that every class has a prototype property that is shared by every instance of the class. So any properties or methods of a class’s prototype can be accessed by every object instantiated by that class.</li>
            <li><span class="word">this</span> in the prototype always refers to the instance that actually calls the method.</li>
            <li>So what’s the difference between an object's own properties and prototype properties? Prototype properties are shared by every instance of the class. This means they’ll all have a property, and it will always be the same value. This value is the same for all the instances and only exists in one place ― as a property of the prototype. This means that it only exists in memory in one place, which is more efficient than each instance having its own value. This is particularly useful for any properties that are the same</li>
            <li>The <span class="word">The Prototype Object is Live</span>, so if a new property or method is added to the prototype, any instances of its class will inherit the new properties and methods automatically, even if that instance has already been created.</li>
            <li>If we change the value of the prototype’s property, this will be reflected in allinstances of the class</li>
            <li>It is not possible to overwrite the prototype by assigning it to a new object literal if class declarations are used</li>
            <li>An object instance can overwrite any properties or methods inherited from its prototype by simply assigning a new value to them</li>
            <li>Any own properties will take precedence over the same prototype property when used in methods</li>
            <li>When a property or method is called, the JavaScript engine will check to see if an object has its own property or method. If it does, it will use that one; otherwise, it will continue up the prototype chain until it finds a match or reaches the top of the chain.</li>
            <li>The prototype can be used to add any new properties and methods after the class has been declared. It should be used to define any properties that will remain the same for every instance of the class</li>
            <li>Never use arrays or objects as a default value in prototype.</li>
            <li>all objects ultimately inherit from the prototype of the <span class="word">Object()</span> constructor function.</li>
            <li>When an object calls a method, the JavaScript engine will check to see if the object has that method. If it doesn’t, it will check if the object’s prototype has the method. If not, it will check whether the prototype’s prototype has it. This continues all the way up the prototype chain, until it reaches the prototype of the <span class="word">Object()</span> constructor function, from which all objects in JavaScript inherit. If the prototype of <span class="word">Object()</span> is without the method, an error will be returned saying the object doesn’t exist:</li>
            <li><span class="examples">class NinjaTurtle extends Turtle {<br>
                constructor(name) {<br>
                    super(name);<br>
                    this.weapon = 'hands';<br>
                }<br>
                attack() { return `Feel the power of my ${this.weapon}!` } <br>
            }</span></li>
            <li>The concept of <span class="word">polymorphism</span> means that different objects can have the same method, but implement it in different ways</li>
            <li> avoid monkey-patching any of the built-in object constructor prototypes, unless you have a very good reason</li>
            <li><span class="research">Look more into constructor functions, built in constructor functions: Object , Array , and Function.... static methods, prototype properties, public/private methods, prototype chain, enumeralbe properties, polymorphism, monkeypatch, property attributes and descriptors, init (), mixins, that and this, </span></li>
        </ul>
    </div> 
    <h1>Notes: Modern JavaScript Development</h1>
    <div>
        <ul>
            <li>A JavaScript <span class="word">library</span> is a piece of code that provides several methods that make it easier to achieve common tasks.</li>
            <li><span class="word">jQuery</span> is the most popular of all the JavaScript libraries used today</li>
            <li>It is used in a huge number of commercial websites and has a plugin system that makes it easy to extend and use to build common web page elements, such as a lightbox or carousel widget.</li>
            <li><span class="word">jQuery</span> was released in 2006, originally as a DOM manipulation library. It has since grown much bigger, and now provides hundreds of methods for selecting nodes, as well as traversing the DOM, animation effects, Ajax and events. It also has its own testing library:QUnit.
            A big advantage of using jQuery is its support for older browsers, particularly Internet Explorer.</li>
            <li>The jQuery library uses the <span class="word">$</span> symbol as a convenient alias for the the global jQuery object that contains all of jQuery's methods. This prevents the global scope from being polluted with any of jQuery’s methods. The <span class="word">$</span> symbol has become synonymous with jQuery, and you can confidently expect that any mention of it implies that jQuery is being used.</li>
            <li><span class="word">Underscore and Lodashare</span> very similar libraries of functions that provide additional functionality to the language. They both provide a large number of utility functions under the namespace <span class="word">_</span>(this is where they get their name from as the <span class="word">_</span> character is often referred to as an 'underscore' or a 'lodash')</li>
            <li>Be careful not to rely on a library and find that you’re learning how to use the library's methods, rather than the language itself. A library should not be used because of a lack of understanding of JavaScript. Instead, it should be used to speed up JavaScript development by making it easier to complete common tasks. </li>
            <li>The <span class="word">coupling</span> of code refers to how dependent certain elements or modules of code are on each other.</li>
            <li>There are a few important points about modules that are worth keeping in mind:

                All code in modules is always in strict mode without the need for 'use strict' and there is no way to opt out of this.
                A module has its own global scope, so any variables created in the top-level of a module can only be accessed within that module.
                The value of this in the top level of a module is undefined , rather than the global object.
                You can't use HTML-style comments in modules (although this isn't very common in any JavaScript program these days).
                A ES6 module file is just a normal JavaScript file, but uses the keyword export to specify any values or functions that are to be made available from the module. </li>
            <li>Having more than one default export will result in a syntax error.</li>
            <li><span class="word">Default exports</span> refer to a single variable, function or class in a module that can be imported without having to be explicitly named</li>
            <li>The alias that is assigned to the imported module does not have to match its name in the actual module.</li>
            <li><span class="word">Model-View-Controller (MVC) </span>is a design pattern that’s been used for a long time in server-side languages. It’s a common way of designing software, and used by server-side frameworks such as Ruby On Rails and Django. In recent years it has been used in JavaScript code to make it easier to organize large-scale web applications.</li>
            <li><span class="word">Models</span> are objects that implement the functionality for creating, reading, updating and deleting (known as CRUD tasks) specific pieces of information about the application, as well as any other associated logic and behavior</li>
            <li><span class="word">Views</span> provide a visual representation of the model showing all the relevant information. In a web application, this would be the HTML displayed on a web page. Views also provide a way for users to interact with an application, usually via forms</li>
            <li><span class="word">Controllers</span> link models and views together by communicating between them. They respond to events, which are usually inputs from a user (entering some data into a form, for example), process the information, then update the model and view accordingly</li>
            <li>One-way data binding is when a change in the model will automatically result in the view being updated. And two-way data binding is when a change in the view automatically updates the model.</li>
            <li><span class="word">Templating languages</span> allow HTML to be separated from the JavaScript program, making maintenance easier because they’re no longer tightly coupled. The templates are often stored in separate files or inside their own script tags, so they can be reused and quickly edited in one place if changes need to be made</li>
            <li><span class="word">Content delivery networks(CDNs)</span> are systems of distributed servers that can deliver web resources, such as JavaScript, CSS or image files to a user based on their geographic location. This means they’re able to deliver the content quickly and efficiently with a high degree of availability. </li>
            <li>The solution is to combine all the scripts into a single minified and compressed file. This file is often named <span class="word">'bundle.min.js'</span> to signify that it’s a number of files bundled together and has also been minified</li>
            <li><span class="word">Minification</span> is the process of removing any unnecessary characters from your code to reduce the file size. This includes all comments, whitespace, and other characters that are superfluous.</li>
            <li><span class="research">reconciliation, react, package managers, npm repository, package.json, yarn, code transpilers, </span></li>
        </ul>
    </div>
            
    <footer>
        &copy; 2020 | Portfolio | Jennifer Spencer
    </footer>
    <script src="main.js"></script>
</body>

</html>